<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>TMbot Web BLE Uploader</title>
    <style>
      body {
        font-family: sans-serif;
        margin: 2rem;
        background: #f7f7f7;
        color: #222;
      }

      textarea {
        width: 100%;
        min-height: 180px;
        font-family: monospace;
        padding: 1rem;
        box-sizing: border-box;
      }

      button {
        padding: 0.6rem 1.2rem;
        margin: 0.3rem 0.3rem 0.3rem 0;
        cursor: pointer;
      }

      #status,
      #log {
        margin-top: 1rem;
        padding: 0.75rem;
        background: #fff;
        border: 1px solid #ccc;
        min-height: 6rem;
        font-family: monospace;
        overflow: auto;
        white-space: pre;
      }

      #log {
        max-height: 240px;
      }
    </style>
  </head>
  <body>
    <h1>TMbot Web Bluetooth uploader</h1>
    <p>
      Paste the grid JSON in the format <code>[[[x0,y0],...],[...]]</code> and use one of the send
      buttons. Inline mode writes a single frame (<= 100 bytes); chunked mode always streams with the
      START/CHUNK/END protocol.
    </p>
    <textarea
      id="grid-input"
      placeholder="[[[0,0],[1,0],[2,0]],[[3,1],[3,2]]]"
      spellcheck="false"
    ></textarea>
    <div>
      <button id="btn-connect">Connect</button>
      <button id="btn-send-inline">Send (inline)</button>
      <button id="btn-send-chunk">Send (chunked)</button>
      <button id="btn-disconnect">Disconnect</button>
    </div>
    <div id="status">BLE status will appear here.</div>
    <div id="log">Logs will appear here.</div>
    <script type="module">
      import { setupClient } from './grid-client.js';

      const textarea = document.getElementById('grid-input');
      const statusBox = document.getElementById('status');
      const logBox = document.getElementById('log');

      const client = setupClient({ statusBox, logBox });

      function parseGridInput() {
        const raw = textarea.value.trim();
        if (!raw) {
          throw new Error('Input is empty');
        }
        return JSON.parse(raw);
      }

      function logError(prefix, error) {
        const line = `[${new Date().toISOString()}] ${prefix}: ${error.message || error}`;
        logBox.textContent += `${line}\n`;
        logBox.scrollTop = logBox.scrollHeight;
      }

      document.getElementById('btn-connect').addEventListener('click', async () => {
        try {
          await client.ensureConnected();
        } catch (err) {
          logError('Connect error', err);
        }
      });

      document.getElementById('btn-send-inline').addEventListener('click', async () => {
        try {
          const grid = parseGridInput();
          await client.sendInline(grid);
        } catch (err) {
          logError('Inline send error', err);
        }
      });

      document.getElementById('btn-send-chunk').addEventListener('click', async () => {
        try {
          const grid = parseGridInput();
          await client.sendChunked(grid);
        } catch (err) {
          logError('Chunked send error', err);
        }
      });

      document.getElementById('btn-disconnect').addEventListener('click', async () => {
        try {
          await client.disconnect();
          logBox.textContent += `[${new Date().toISOString()}] Disconnected\n`;
        } catch (err) {
          logError('Disconnect error', err);
        }
      });
    </script>
  </body>
</html>
